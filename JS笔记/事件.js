//================================================== 事件 ==================================================
  /* 
    1.事件：浏览器赋予元素天生默认的一些行为，不论是否绑定相关的方法。
          只要行为操作进行了，那么一定会触发相关的事件行为。（天生就有事件，只是事件行为绑定为 null）
    2.事件绑定：给元素的某个事件行为绑定方法，目的是行为触发可以做自己想做的事情
    3.事件绑定分为 DOM0 事件绑定 和 DOM2事件绑定
  */  
  let div = document.createElement('div');
   //==================== DOM0事件绑定 ====================
    /* 
      原理：给DOM元素对象的某一个私有事件属性 赋值 函数（ 不是所有的事件类型都支持这种方式，元素有哪些事件属性，才能给其绑定方法）
      注意：只给给当前元素的某一个事件绑定一个方法（绑定多个，最后一个会覆盖之前所有的）
    */
    // 绑定事件
      div.onclick = ()=>{
        console.log(1);
      }
    //移除事件绑定 
      div.onclick = null;
  
  //==================== DOM2事件绑定 ====================
    /* 
      原理：基于原型链查找机制，找到 EvevtTarget.prototype 上的 addEventListener 方法执行（性能 DOM0 比 DOM2好，不用去查找）
      方法执行：它是基于( 浏览器事件队(Event Queue)列机制 ) 完成的
      addEventListener 就是向事件队列不断的添加事件。
      removeEventListener 向事件队列中移除
      重点：当事件触发时，就去事件队列里面 找到相匹配的 事件行为 拿来执行
            因此，DOM2可以帮定多个不同的事件行为，相同的不会再次绑定，必须是事件，行为，传播机制都一样才可以 
            DOM0 和 DOM2 同时绑定，谁先绑定先执行谁
    */
    //绑定事件: false=>冒泡阶段; true=>捕获阶段(不写默认为false) 
      //IE6~8 div.attachEvent('onclick',()=>{})
      div.addEventListener('click',()=>{
        console.log(1)
      },false);
    //移除事件（要求事件，行为(要求是同一个函数)，传播机制 都要一样）
      //注意：这样移除不了，因为两个函数是两个堆内存
      div.removeEventListener('click',()=>{
        console.log(1)
      },false);
      //只能用把函数单独提取出来，才能移除
      let anonymous = ()=>{ console.log(111) }
      div.addEventListener('click',anonymous,false);
      div.removeEventListener('click',anonymous,false);

//================================================== 事件对象 ==================================================
  /* 
    事件对象：当事件行为触发，方法被执行，还会把当前操作的相关信息传递给这个函数 => 事件对象（event）
    ev.type   =>  事件类型（比如click）
    ev.target =>  事件源（操作的是那个元素，那个元素就是事件源）（ 在不兼容的浏览器中，可以使用 ev.srcElement ）
    ev.preventDefault()  =>  用来阻止默认行为的方法（不兼容的浏览器可以使用 ev.returnValue = false）
    ev.stopPropagation()  => 阻止事件冒泡传播（不兼容的浏览器可以使用 ev.cancelBubble = true）
  */
  /* 
    重点：事件对象和函数以及给你绑定事件没啥关系，它存储的是当前本次操作的相关信息，操作一个只能有一份信息，所以在哪个方法中获取的信息都是一样的
    第二次操作，存储的信息会把上一次操作存储的信息替换掉（下面是例子）
  */
  /* 
    浏览器执行：1、捕获到当前操作的行为（把操作信息获取到，通过创建MouseEvent事件对象(这里还有键盘事件对象等)，得到event事件对象）
               2、通过所有绑定的方法（符合条件的开始执行），并且把ev当做实参传递给每个方法。
               3、然后再重新触发这个事件行为，会重新获取本次操作的相关信息，用新的信息替换老的信息。
  */ 
    var obj = null;
    div.addEventListener('click',ev=>{
      console.log(ev);
      obj = ev; 
    });
    div.addEventListener('click',ev=>{
      // 返回true，代表同一个事件对象。这里一开始传的是同一个ev对象，让一个把ev的堆地址赋值给了obj
      console.log(obj === ev);      
    });

//================================================== 事件传播 ==================================================
  /* 
    事件传播分为三个阶段：捕获阶段、目标阶段、事件冒泡
      在Event上记录了这个传播机制
        AT_TARGET: 2 （目标阶段）
        BUBBLING_PHASE: 3（事件冒泡）
        CAPTURING_PHASE: 1（事件捕获）
        path：传播的路径（是个数组）
      捕获阶段：从最外层向最里层事件源依次进行查找（目的：是为了冒泡阶段事先计算好传播的层级路径）
      目标阶段：当前元素的相关事件行为触发（事件源）
      事件冒泡：触发当元素的某一个事件行为，不仅它的这个行为被触发了，而且它的所以祖先元素（一直到window）相关的事件
                都会依次会被触发（由内到外）
        重点：产生你冒泡机制时，ev事件对象是也是当前被点击的元素，依次冒泡到父元素，再把事件对象传给父级，不是父级元素的ev事件对象    
      DOM0绑定的方法只能在 目标阶段 和 冒泡阶段 触发执行
      DOM2绑定的方法我们可以控制在捕获阶段执行（false：冒泡阶段;true：捕获阶段(补长用，没什么用)）
  */ 

//================================================== 事件委托 ==================================================
  /* 
    事件委托：触发当元素的某一个事件行为，不仅它的这个行为被触发了，而且它的所以祖先元素（一直到window）相关的事件
             把它的事件行为绑定到父元素上。利用事件冒泡来完成
  */
  
