//================================================= ^与$ ===============================================
  var reg = /^\d/; //必须以数字开始
  reg.test("lalala"); //false
  reg.test("2020lala"); //true
  reg.test("lala2020"); //false

  var reg = /\d$/;
  reg.test("lalala"); //false
  reg.test("2020lala"); //true
  reg.test("lala2020"); //false

  /* 
    两个都不加【包含符合规则的内容即可】
  */
  var reg = /\d/;  //【包含数字即可】
  var reg = /\d+/; //【包含数字即可】
  //【这两个区别在于如果进行多次查找 那么第一种找到一个就停止了，第二种就是会多次查找】
  reg.test('2020lala') // => true

  /* 
    两个都加；字符串只能是和规则一致的内容
  */
  var reg = /^\d+$/;
  reg.test('2020') //true   //以数字开头以数字结尾

  //举个例子：验证手机号码(11位，第一个数字是1即可)
  var reg = /^1\d{10}/;   // 以1开头，后面可以的数字必须是10位，
  var reg = /^1\d{10}$/;  // 以1开头，后面出现数字必须出现10位，并且是

  var reg = /^2.3$/ //【这里的.代表的不是小数点. 而是代表的是出来\n的任意字符】
  reg.test('2.3') // => true
  reg.test('2@3') // => true
  reg.test('23')  // => false 【这个其实是正则表达式 2.已经匹配成功了，想再次匹配3，发现没有，返回false】
  var reg = /^2\.3$/ //【这里的.被转义，只能代表小数点 .】

  //只想匹配 字符串\d;
  var str = '\d';
  var reg = /^\d$/;
  reg.test(str);   // fasle 
  /* 
    reg的\d代表代表 0-9 之间的数字，意思就是以数字开头，以数字结尾。
    因此写成 /^\\d$/ 再来匹配，但还是 false。
    因为 字符串中的 \d 也有特殊含义【\n代表换行符】，也不知道为什么 \d 代表一个字母 d，那么因此不符合 \d 开头，\d 结尾的
    因此 字符串也得写成 '\\d'。
    最终 str = '\\d'; reg = /^\\d$/; reg.test(str); 返回 true
  */

//================================================= x|y ===============================================
  var reg = /^18|29$/; //【这个|的优先级最低，表达的意思就是：以18开头或者以29结尾】
  reg.test('232129'); // true
  reg.test('18');   //=>true
  reg.test('29');   //=>true
  reg.test('129');  //=>true
  reg.test('189');  //=>true
  reg.test('1829'); //=>true
  reg.test('829');  //=>true
  reg.test('182');  //=>true
  //只想要匹配 要么以18开头结尾 要么以29开头结尾 应该写成：
  var reg = /^(18|29)$/;
  reg.test('189') //=>false
  reg.test('18'); //=>true

//================================================= [] ===============================================
  /* 
    中括号中出现的字符一般都代表本身的含义
  */
  var reg = /^[@+]+$/;  //意思：本来 + 代表 1次到多次，但是在[]代表本身含义，意思就是要么 以@开头结尾，要么以 +开头结尾【可以出现多次】 
  reg.test('@1'); // false 里面包含了1
  reg.test('+');  // true 
  reg.test('@@'); // true 可以出现多次
  var reg = /^[@+]$/; 
  reg.test('@@'); //false 这样就不行，没有 + 号，只能以 @开头结尾 或者以 +开头结尾
  reg.test('@+'); //false
  /* 
    只有\在 [] 里有意义，因为 \ 的优先级比 [] 高
  */
  var reg = /^[\d]+$/; // 按之前 [] 里面代表本身含义的想法去匹配 \ 或者 d，发现下边两条都是 false
  reg.test('\\'); // false
  reg.test('d') //false
  reg.test('9') //true
  //想要匹配 \ 或者 d 写成
  var reg = /^[\\d]+$/;
  /* 
    [] 中不存在多位数
  */
  var reg = /^[10-59]$/; //原本的意思想 匹配 10-29 中的数字，但是不存在多位数。因此 这个表示的意思是：1或者0-2或者9
    reg.test('4'); //true;
    reg.test('25'); //false
  var reg = /^[(10-29)]$/; //小括号包起来也没用，因为优先级时相同的
    reg.test('(');
  var reg = /^[\(10-29\)]$/;
    reg.test('(');  //使用\想转义(，\( 在正则表里没有这个东西，因此无意义，还是上面的效果
    reg.test('\\'); //false【想匹配 \，但是\比[]的优先级高，那么它转 ( 完,\已经不在了，因此也匹配不到】 

    /(^[0-9]$)|(^[1-2][0-9]$)|(30)$/.test(2)  //判断是否在 0-30 之间的数字