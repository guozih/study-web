/* 
  验证是否为有效数字
    规则分析
      1。可能出现 + - 号，也可能不出现 [+-]?
      2。一位0-9都可以，多位首位不能为0 (\d|([1-9]\d+))
      3。小数部分可能有可能没有，一旦有后面必须有小数点加数字(\.\d+)?
*/
var reg = /^[+-]?(\d|([1-9]\d+))(\.\d+)?$/;

/* 
  验证密码 6~16位数字，字母，下划线
*/
var reg = /^\w{6,16}$/;

/* 
  验证真实姓名
  1.汉字：/^[\u4E00-\u9FA5]$/;
  2.名字长度2~10位
  3.可能出现译名 ·汉字
*/
var reg = /^[\u4E00-\u9FA5]{2,10}(·[\u4E00-\u9FA5]{1,10})*$/;
reg.test('列奥纳多·迪·皮耶罗·达·芬奇') //true

/* 
  验证邮箱
*/
var reg = /^\w+((-\w+)|(\.\w+))*@[A-Za-z0-9]+((\.|-)[A-Za-z0-9]+)*\.[A-Za-z0-9]+$/;
console.log(reg.test('guo.zi-hong@163.com'));
console.log(reg.test('gzh@guo-zi-hong.com'));
console.log(reg.test('g1662980964@163.com'));
console.log(reg.test('1662980964@qq.com'));
/* 
  第一部分匹配 \w+((-\w+)|(\.\w+))*
    \w 匹配字母数字下划线【1到多位】
    ((-\w+)|(\.\w+))* 这个整体【(-\w+) 或者 (\.\w+)】出现 0到多次
      -\w+   ：-、数字、字母、下划线【数字、字母、下划线可以出现0到多位】
      \.\w+ ：.、数字、字母、下划线【数字、字母、下划线可以出现0到多位】
    例子：guo-zi-hong：guo 匹配的是 \w 
                      -zi 匹配的是 -\w+
                      -hong 匹配的是 -\w+
          guo.zi.hong: guo 匹配的是 \w 
                      .zi 匹配的是 \.\w+
                      .hong 匹配的是 \.\w+
          guo-zi.hong：guo 匹配的是 \w 
                      .zi 匹配的是 -\w+
                      .hong 匹配的是 \.\w+
  由于这部分可以得出：邮箱的名字可以有 "数字、字母、下划线、.、-" 但是 -. 不能连续出现【 guo-.zi[这样为false] 必须跟着东西】
                    也不能作为开始
*/
/* 
  第二部分  @[A-Za-z0-9]+
    @后面紧跟着：数字、字母。不能跟别的【1到多位】
*/
/* 
  第三部分 ((\.|-)[A-Za-z0-9]+)*
    对 @ 后面名字的补充
    多域名    .com.cn
    企业域名  gzh@guo-zi-hong.com 
      gzh   匹配第一部分  
      @guo  匹配第二部分
      -zi   匹配第三部分
      -hong 匹配第三部分
      .com  匹配第四部分
*/  
/* 
  第四部分 \.[A-Za-z0-9]+ 
    这部分负责匹配的是最后的域名
    例如： xxx.com  xxx.cn  xxx.vip 等 
    不管什么邮箱，最后肯定会有一个 .域名结尾
*/

/* 
  身份证号码
  1。一共18位
  2。大写X【X代表10】
    1.身份证前6位：省市县
    2.中间8位：年月日
    3.最后四位：
      最后一位：  X 或者 数字
      倒数第二位：偶数：女 奇数：男
      前两位：其余是经过算法算出来的
*/
//最简单的正则
var reg = /^\d{17}(\d|X)$/;
//按照上面的3条规律去写
/* 
  小括号分组的第一个作用：改变优先级
  小括号分组的第二个作用：分组捕获，不仅可以把大正则匹配的信息捕获到，还可以单独捕获到每个小分组的内容
*/
var reg = /^(\d{6})(\d{4})(\d{2})(\d{2})\d{2}(\d)(\d|X)$/;
reg.exec('140622199710281218'); 
/* 
  得到的捕获数据，是每个 () 的内容，不在小括号里面的不会捕获。因此 写正则 不仅要验证，还要捕获
  ["140622199710281218", "140622", "1997", "10", "28", "1", "8", index: 0, input: "140622199710281218", groups: undefined]
*/


/* 
  判断是否在 0-30 之间的数字
*/
/(^[0-9]$)|(^[1-2][0-9]$)|(30)$/.test(2)  