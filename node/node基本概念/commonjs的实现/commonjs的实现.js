//==============================================  模块分类规范  ======================================================
/* 
    模块中的规范：    1.commonJS规范      2.es6Module
        es6Module：静态导入【只能在脚本的头部导入】【发送http请求获取文件】
            好处：在编译的时候就可以知道用到了哪些变量或者文件，可以通过打包工具实现 
            tree-shaking【用来在打包编译前消除 es6 module 中未使用的代码模块功能】【消除没有使用的依赖，把有用的依赖构建成树状结构】
        commonJS规范：动态导入【可以在代码中导入】
            默认不支持 tree-shaking
*/

//==============================================  commonJS规范  ======================================================
/* 
    commonJS 模块定义了自己的规范，按照规范来使用就可以【3个规范】
    1. 如果想使用哪个模块 就require谁（后缀可以省略，默认会找 .js 文件，没有js就找 .json）
    2. 如果这个模块需要被别人使用，需要导出具体的内容
    3. 在 node 中每个文件【js、json】都是一个文件
    4. 一个包中有多个模块（每个包都配置一个 package.json 文件）
*/

//==============================================  require函数原理  ======================================================
// const r = require('./a')
// console.log(r);
/*
    上边的 require('./a) 相当于下边的这段代码
    原理:    1. 读取文件
            2. 包装函数，设置参数
            3. 默认返回 module.exports 对象
*/
// const r = (function(module,exports,require,__dirname,__filename){
//     module.exports = 'hello'
//     return module.exports;
// })()

//==============================================  模块的实现  ======================================================
/* 
    模块的实现：1. 实现一个 require 方法
               2. Module._load 实现模块的加载
               3. Module._resolveFilename 【把文件名解析成一个绝对路径】
               4. 实现模块的缓存（根据绝对路径进行对模块的缓存）
                    【module.exports会在第一次缓存起来，后续使用的话，会取上次的返回值】
*/
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         
// ==================================================  module.exports缓存例子  ==============================================
// setInterval(()=>{
// 	//如果导出的数据是一个普通类型的值，由于第一次引入过来，node 会进行缓存，下次取值是取到上次缓存的值，那么这个值还是第一次引入的值，一直不变
// 	//如果导出的是一个引用对象，由于是缓存的是内存地址，所以里边的值也会变
// 	const r = require('./a') 
// 	console.log(r); 
// },1000) 



